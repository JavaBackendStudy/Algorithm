# [프로그래머스] 2의 영역

---

## 문제 링크:

[문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/181894)

## 문제 설명:

정수 배열 `arr`가 주어집니다. 배열 안의 2가 모두 포함된 가장 작은 연속된 부분 배열을 return 하는 solution 함수를 완성해 주세요.

단, `arr`에 2가 없는 경우 [-1]을 return 합니다.

---

### 제한사항

- 1 ≤ `arr`의 길이 ≤ 100,000
    - 1 ≤ `arr`의 원소 ≤ 10

---

### 입출력 예

| arr | result |
| --- | --- |
| [1, 2, 1, 4, 5, 2, 9] | [2, 1, 4, 5, 2] |
| [1, 2, 1] | [2] |
| [1, 1, 1] | [-1] |
| [1, 2, 1, 2, 1, 10, 2, 1] | [2, 1, 2, 1, 10, 2] |

---

### 입출력 예 설명

입출력 예 #1

- 2가 있는 인덱스는 1번, 5번 인덱스뿐이므로 1번부터 5번 인덱스까지의 부분 배열인 [2, 1, 4, 5, 2]를 return 합니다.

입출력 예 #2

- 2가 한 개뿐이므로 [2]를 return 합니다.

입출력 예 #3

- 2가 배열에 없으므로 [-1]을 return 합니다.

입출력 예 #4

- 2가 있는 인덱스는 1번, 3번, 6번 인덱스이므로 1번부터 6번 인덱스까지의 부분 배열인 [2, 1, 2, 1, 10, 2]를 return 합니다.

---

※ 2023년 04월 27일 입출력 예, 입출력 예 설명 및 예시 테스트 케이스가 수정 되었습니다.

## 문제 풀이:

```java
import java.util.*;
class Solution {
    public int[] solution(int[] arr) {
        int start=-1;
        int end=-1;
        boolean flag = false;

        for (int i=0;i<arr.length;i++) {
            if (arr[i]==2) {
                if (!flag) {
                    start=i;
                    end=i;
                    flag=true;
                } else {
                    end=i;
                }
            }
        }

        if (!flag) {
            return new int[] {-1};
        }
        return Arrays.copyOfRange(arr, start, end + 1);
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (1.18ms, 75.7MB)
테스트 2 〉	통과 (0.50ms, 74.5MB)
테스트 3 〉	통과 (2.16ms, 94.5MB)
테스트 4 〉	통과 (2.65ms, 97.2MB)
테스트 5 〉	통과 (3.08ms, 109MB)
테스트 6 〉	통과 (0.53ms, 89.3MB)
테스트 7 〉	통과 (3.00ms, 90.2MB)
테스트 8 〉	통과 (1.92ms, 101MB)
테스트 9 〉	통과 (0.48ms, 98.6MB)
테스트 10 〉	통과 (2.79ms, 94.9MB)
테스트 11 〉	통과 (0.53ms, 83MB)
테스트 12 〉	통과 (2.22ms, 89.3MB)
테스트 13 〉	통과 (0.32ms, 85.7MB)
테스트 14 〉	통과 (2.07ms, 87.6MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

### **문제 풀이 해석:**

배열의 인덱스 값이 2인 부분으로 시작해서 2로 끝나는 지점까지의 배열을 return 하는 문제였다.

일단 start와 end의 값을 -1로 초기화 한 후 flag라는 boolean의 값을 가질 변수도 한 개 만들었다.

이 후 배열을 순회하면서 2를 만난다면 start와 end를 그 인덱스로 바꿔준 후 flag를 true로 만든다. flag를 true로 만들어준 이유는 이 후 다른 2를 만났을때 end의 값을 바꿔줘야 하기때문이다. 이 후 return 할때 Array.copyOfRange 메서드를 사용해 범위의 값을 복사해줬다.