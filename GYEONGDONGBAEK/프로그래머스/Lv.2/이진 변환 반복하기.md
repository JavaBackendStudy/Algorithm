# [프로그래머스] 이진 변환 반복하기

## 문제 링크:

[문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/70129)

## 문제 설명:

0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.

1. x의 모든 0을 제거합니다.
2. x의 길이를 c라고 하면, x를 "c를 2진법으로 표현한 문자열"로 바꿉니다.

예를 들어, `x = "0111010"`이라면, x에 이진 변환을 가하면 `x = "0111010" -> "1111" -> "100"` 이 됩니다.

0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 "1"이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- s의 길이는 1 이상 150,000 이하입니다.
- s에는 '1'이 최소 하나 이상 포함되어 있습니다.

---

### 입출력 예

| s | result |
| --- | --- |
| "110010101001" | [3,8] |
| "01110" | [3,3] |
| "1111111" | [4,1] |

---

### 입출력 예 설명

입출력 예 #1

- "110010101001"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.

| 회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
| --- | --- | --- | --- | --- |
| 1 | "110010101001" | 6 | 6 | "110" |
| 2 | "110" | 1 | 2 | "10" |
| 3 | "10" | 1 | 1 | "1" |
- 3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, `[3,8]`을 return 해야 합니다.

입출력 예 #2

- "01110"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.

| 회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
| --- | --- | --- | --- | --- |
| 1 | "01110" | 2 | 3 | "11" |
| 2 | "11" | 0 | 2 | "10" |
| 3 | "10" | 1 | 1 | "1" |
- 3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, `[3,3]`을 return 해야 합니다.

입출력 예 #3

- "1111111"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.

| 회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
| --- | --- | --- | --- | --- |
| 1 | "1111111" | 0 | 7 | "111" |
| 2 | "111" | 0 | 3 | "11" |
| 3 | "11" | 0 | 2 | "10" |
| 4 | "10" | 1 | 1 | "1" |
- 4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, `[4,1]`을 return 해야 합니다.

## 문제 풀이:

```java
class Solution {
    public int[] solution(String s) {
        int[] answer = new int[2];
        while(s.length()>1){ 
          int cnt=0;
          for(int i=0;i<s.length();i++) {
            if(s.charAt(i)=='0') answer[1]++;
            else cnt++;
         }
          s=Integer.toBinaryString(cnt);
          answer[0]++;
         }
        return answer;
    }
}
----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.07ms, 79.6MB)
테스트 2 〉	통과 (8.72ms, 76.2MB)
테스트 3 〉	통과 (0.05ms, 73.3MB)
테스트 4 〉	통과 (0.04ms, 78.8MB)
테스트 5 〉	통과 (0.06ms, 74.4MB)
테스트 6 〉	통과 (0.11ms, 73.6MB)
테스트 7 〉	통과 (0.12ms, 74.3MB)
테스트 8 〉	통과 (0.12ms, 75.3MB)
테스트 9 〉	통과 (5.96ms, 76.1MB)
테스트 10 〉	통과 (8.67ms, 78MB)
테스트 11 〉	통과 (5.85ms, 87.4MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

### **문제 풀이 해석:**

0의 개수와 1의 개수를 구분했다. 1의 개수를 저장하기 위해 cnt라는 변수를 설정했다. 리턴값이 배열이기 때문에, 반복문을 순회하면서 0을 만나면 배열에 저장하고, 1을 만나면 cnt에 저장을 하였다. 이 후 반복문이 끝나면 toBinaryString 메서드를 사용하여 그 개수를 2진법 문자열로 바꿔주었고, 그때마다 배열의 값을 증가시켰다.