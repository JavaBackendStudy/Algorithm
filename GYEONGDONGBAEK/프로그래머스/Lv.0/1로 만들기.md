# [프로그래머스] 1로 만들기

---

## 문제 링크:

[문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/181880)

## 문제 설명:

정수가 있을 때, 짝수라면 반으로 나누고, 홀수라면 1을 뺀 뒤 반으로 나누면, 마지막엔 1이 됩니다. 예를 들어 10이 있다면 다음과 같은 과정으로 1이 됩니다.

- 10 / 2 = 5
- (5 - 1) / 2 = 4
- 4 / 2 = 2
- 2 / 2 = 1

위와 같이 4번의 나누기 연산으로 1이 되었습니다.

정수들이 담긴 리스트 `num_list`가 주어질 때, `num_list`의 모든 원소를 1로 만들기 위해서 필요한 나누기 연산의 횟수를 return하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 3 ≤ `num_list`의 길이 ≤ 15
- 1 ≤ `num_list`의 원소 ≤ 30

---

### 입출력 예

| num_list | result |
| --- | --- |
| [12, 4, 15, 1, 14] | 11 |

---

### 입출력 예 설명

입출력 예 #1

- 12는 3번, 4는 2번, 15는 3번, 1은 0번, 14는 3번의 연산이 필요하기 때문에 총 11번의 연산이 필요합니다.

## 문제 풀이:

```java
class Solution {
    public int solution(int[] num_list) {
        int answer = 0;
        for(int i=0;i<num_list.length;i++){
            while(num_list[i]>1){
                if(num_list[i]%2==0){
                    num_list[i]/=2;
                    answer++;
                }else{
                    num_list[i]=(num_list[i]-1)/2;
                    answer++;
                }
            }
        }
        return answer;
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.02ms, 75.4MB)
테스트 2 〉	통과 (0.02ms, 72.8MB)
테스트 3 〉	통과 (0.01ms, 77.8MB)
테스트 4 〉	통과 (0.02ms, 72MB)
테스트 5 〉	통과 (0.03ms, 77.8MB)
테스트 6 〉	통과 (0.02ms, 78.2MB)
테스트 7 〉	통과 (0.02ms, 73.9MB)
테스트 8 〉	통과 (0.01ms, 72.6MB)
테스트 9 〉	통과 (0.01ms, 76.8MB)
테스트 10 〉	통과 (0.02ms, 77MB)
테스트 11 〉	통과 (0.02ms, 74.3MB)
테스트 12 〉	통과 (0.02ms, 65.8MB)
테스트 13 〉	통과 (0.02ms, 71.7MB)
테스트 14 〉	통과 (0.02ms, 74MB)
테스트 15 〉	통과 (0.02ms, 73.5MB)
테스트 16 〉	통과 (0.01ms, 75.7MB)
테스트 17 〉	통과 (0.02ms, 74.5MB)
테스트 18 〉	통과 (0.02ms, 75.3MB)
테스트 19 〉	통과 (0.01ms, 76.8MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

```java
class Solution {
    public int solution(int[] num_list) {
        int answer = 0;
        for(int i = 0;num_list.length>i;i++){
            while(num_list[i]!=1){
                num_list[i]/=2;
                answer++;
            }
        }
        return answer;
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.02ms, 71.9MB)
테스트 2 〉	통과 (0.02ms, 77.8MB)
테스트 3 〉	통과 (0.03ms, 73.8MB)
테스트 4 〉	통과 (0.02ms, 75.7MB)
테스트 5 〉	통과 (0.02ms, 76.9MB)
테스트 6 〉	통과 (0.02ms, 72MB)
테스트 7 〉	통과 (0.02ms, 72.9MB)
테스트 8 〉	통과 (0.01ms, 73.6MB)
테스트 9 〉	통과 (0.03ms, 71.5MB)
테스트 10 〉	통과 (0.02ms, 73.7MB)
테스트 11 〉	통과 (0.03ms, 75.2MB)
테스트 12 〉	통과 (0.04ms, 75.3MB)
테스트 13 〉	통과 (0.02ms, 70.8MB)
테스트 14 〉	통과 (0.02ms, 79.6MB)
테스트 15 〉	통과 (0.02ms, 73.1MB)
테스트 16 〉	통과 (0.02ms, 75.1MB)
테스트 17 〉	통과 (0.02ms, 77.7MB)
테스트 18 〉	통과 (0.02ms, 68MB)
테스트 19 〉	통과 (0.02ms, 74MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

### **문제 풀이 해석:**

조건을 해석하면 되는 쉬운 문제였다. 

첫번째 풀이는 조건 그대로 풀었는데 문제 조건에 홀수라면 1을 뺀 뒤 반으로 나누라고 되어있는데, 배열의 자료형이 int 형 이기때문에 홀수일때 -1 을 안하고 반으로 나눠도 똑같은 값을 리턴하기 때문에 조건문을 1개 줄일 수 있었다.