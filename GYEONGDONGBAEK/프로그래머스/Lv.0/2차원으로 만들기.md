# [프로그래머스] 2차원으로 만들기

---

## 문제 링크:

[https://school.programmers.co.kr/learn/courses/30/lessons/12943](https://school.programmers.co.kr/learn/courses/30/lessons/120842)

## 문제 설명:

정수 배열 `num_list`와 정수 `n`이 매개변수로 주어집니다. `num_list`를 다음 설명과 같이 2차원 배열로 바꿔 return하도록 solution 함수를 완성해주세요.

`num_list`가 [1, 2, 3, 4, 5, 6, 7, 8] 로 길이가 8이고 `n`이 2이므로 `num_list`를 2 * 4 배열로 다음과 같이 변경합니다. 2차원으로 바꿀 때에는 num_list의 원소들을 앞에서부터 n개씩 나눠 2차원 배열로 변경합니다.

| num_list | n | result |
| --- | --- | --- |
| [1, 2, 3, 4, 5, 6, 7, 8] | 2 | [[1, 2], [3, 4], [5, 6], [7, 8]] |

---

### 제한사항

- `num_list`의 길이는 `n`의 배 수개입니다.
- 0 ≤ `num_list`의 길이 ≤ 150
- 2 ≤ `n` < `num_list`의 길이

---

### 입출력 예

| num_list | n | result |
| --- | --- | --- |
| [1, 2, 3, 4, 5, 6, 7, 8] | 2 | [[1, 2], [3, 4], [5, 6], [7, 8]] |
| [100, 95, 2, 4, 5, 6, 18, 33, 948] | 3 | [[100, 95, 2], [4, 5, 6], [18, 33, 948]] |

---

### 입출력 예 설명

입출력 예 #1

- `num_list`가 [1, 2, 3, 4, 5, 6, 7, 8] 로 길이가 8이고 `n`이 2이므로 2 * 4 배열로 변경한 [[1, 2], [3, 4], [5, 6], [7, 8]] 을 return합니다.

입출력 예 #2

- `num_list`가 [100, 95, 2, 4, 5, 6, 18, 33, 948] 로 길이가 9이고 `n`이 3이므로 3 * 3 배열로 변경한 [[100, 95, 2], [4, 5, 6], [18, 33, 948]] 을 return합니다.

## 문제 풀이:

```java
class Solution {
    public int[][] solution(int[] num_list, int n) {
        int[][] answer = new int [num_list.length/n][n];
        int cnt=0;
        for(int i=0;i<answer.length;i++){
            for(int j=0;j<n;j++){
                answer[i][j]=num_list[cnt];
                cnt++;
            }
        }
        return answer;
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.03ms, 81.2MB)
테스트 2 〉	통과 (0.02ms, 77.9MB)
테스트 3 〉	통과 (0.03ms, 73.3MB)
테스트 4 〉	통과 (0.01ms, 78.2MB)
테스트 5 〉	통과 (0.01ms, 73.4MB)
테스트 6 〉	통과 (0.02ms, 76.2MB)
테스트 7 〉	통과 (0.02ms, 82.1MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

```java
class Solution {
    public int[][] solution(int[] num_list, int n) {
        int[][] answer = new int[num_list.length / n][n];
        for(int i = 0; i < answer.length; i++) {
            System.arraycopy(num_list, i * n, answer[i], 0, n);
						//num_list: 원본 배열
						//i * n: 원본 배열에서 복사를 시작할 위치 (i번째 행에 해당하는 데이터의 시작점)
						//answer[i]: 데이터를 복사할 대상 배열 (2차원 배열의 i번째 행)
						//0: 대상 배열에서 복사를 시작할 위치 (행의 시작점)
						//n: 복사할 원소의 개수 (각 행에는 n개의 원소가 있음)
        } 
        return answer;
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.03ms, 78.5MB)
테스트 2 〉	통과 (0.04ms, 70.1MB)
테스트 3 〉	통과 (0.03ms, 80.1MB)
테스트 4 〉	통과 (0.03ms, 72.7MB)
테스트 5 〉	통과 (0.02ms, 74.4MB)
테스트 6 〉	통과 (0.02ms, 71.9MB)
테스트 7 〉	통과 (0.02ms, 73.9MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

### **문제 풀이 해석:**

1차원 배열로 되어있는 배열을 2차원 배열로 바꾸는 문제였다. 1차원 배열의 길이가 n의 배수이므로 나머지는 상관할 필요가 없었다. 처음 풀었을때는 행, 열을 구분하기 위해 2중 for문을 사용했는데, for문을 한개 줄일 수 있을까를 고민하다가 배열 복사 메서드중 하나인 System.arraycopy를 이용했다.