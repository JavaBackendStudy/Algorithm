# [프로그래머스] 모스부호

---

## 문제 링크:

[https://school.programmers.co.kr/learn/courses/30/lessons/120838](https://school.programmers.co.kr/learn/courses/30/lessons/120838)

## 문제 설명:

머쓱이는 친구에게 모스부호를 이용한 편지를 받았습니다. 그냥은 읽을 수 없어 이를 해독하는 프로그램을 만들려고 합니다. 문자열 `letter`가 매개변수로 주어질 때, `letter`를 영어 소문자로 바꾼 문자열을 return 하도록 solution 함수를 완성해보세요.

모스부호는 다음과 같습니다.

`morse = { 
    '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',
    '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',
    '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',
    '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',
    '-.--':'y','--..':'z'
}`

---

### 제한사항

- 1 ≤ `letter`의 길이 ≤ 1,000
- return값은 소문자입니다.
- `letter`의 모스부호는 공백으로 나누어져 있습니다.
- `letter`에 공백은 연속으로 두 개 이상 존재하지 않습니다.
- 해독할 수 없는 편지는 주어지지 않습니다.
- 편지의 시작과 끝에는 공백이 없습니다.

---

### 입출력 예

| letter | result |
| --- | --- |
| ".... . .-.. .-.. ---" | "hello" |
| ".--. -.-- - .... --- -." | "python" |

---

### 입출력 예 설명

입출력 예 #1

- .... = h
- . = e
- .-.. = l
- .-.. = l
- -- = o
- 따라서 "hello"를 return 합니다.

입출력 예 #2

- .--. = p
- .-- = y
- = t
- .... = h
- -- = o
- . = n
- 따라서 "python"을 return 합니다.

---

- a ~ z에 해당하는 모스부호가 순서대로 담긴 배열입니다.
- `{".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."}`

## 문제 풀이:

```java
class Solution {
    public String solution(String letter) {
        String answer = "";
        String[] strarr={".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        String[] str=letter.split(" ");
        for(int i=0;i<str.length;i++){
            for(int j=0;j<strarr.length;j++){
                if(str[i].equals(strarr[j])){
                answer+=(char)(j+'a');
                }
            }
        }
        return answer;
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (16.88ms, 78.6MB)
테스트 2 〉	통과 (11.17ms, 84.7MB)
테스트 3 〉	통과 (10.72ms, 79.3MB)
테스트 4 〉	통과 (9.39ms, 77.9MB)
테스트 5 〉	통과 (14.02ms, 82.2MB)
테스트 6 〉	통과 (12.63ms, 76MB)
테스트 7 〉	통과 (13.34ms, 85.8MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

```java
class Solution {
    public String solution(String letter) {
        StringBuilder sb = new StringBuilder();
        String[] strarr={".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        String[] str=letter.split(" ");
        for(int i=0;i<str.length;i++){
            for(int j=0;j<strarr.length;j++){
                if(str[i].equals(strarr[j])){
                   sb.append((char)(j+'a'));
                }
            }
        }
        return sb.toString();
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.13ms, 71.2MB)
테스트 2 〉	통과 (0.16ms, 78MB)
테스트 3 〉	통과 (0.14ms, 83.4MB)
테스트 4 〉	통과 (0.11ms, 73.4MB)
테스트 5 〉	통과 (0.10ms, 74.6MB)
테스트 6 〉	통과 (0.12ms, 77.1MB)
테스트 7 〉	통과 (0.21ms, 70.9MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

### **문제 풀이 해석:**

모스부호가 문제에 주어져 있었다. 그걸로 배열을 만들어 그 모스부호에 맞는 알파벳을 연결시켜야 했다. 그래서 ASCII 코드를 이용한 뒤 char로 형변환을 시켜 문제를 풀었다.

처음에 String에 더하는 풀이를 이용했는데, String은 불변성을 가지는 객체라, 만약 String str=’a’ 에 ‘b’ 를 더한다면 바로 덧셈이 되는게 아니라 “ab” 라는 새로운 객체를 만들고 str이 이 객체의 주소를 참조하고 ‘a’ 객체는 GC에 의해 지워지는 과정이 있기때문에 시간이 많이 걸린다. 그래서 가변성을 가지는 StringBuilder를 사용해 문제를 다시 풀었다.