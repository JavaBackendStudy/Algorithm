# [프로그래머스] 수열과 구간쿼리 1

---

## 문제 링크:

[문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/181883)

## 문제 설명:

정수 배열 `arr`와 2차원 정수 배열 `queries`이 주어집니다. `queries`의 원소는 각각 하나의 `query`를 나타내며, `[s, e]` 꼴입니다.

각 `query`마다 순서대로 `s` ≤ `i` ≤ `e`인 모든 `i`에 대해 `arr[i]`에 1을 더합니다.

위 규칙에 따라 `queries`를 처리한 이후의 `arr`를 return 하는 solution 함수를 완성해 주세요.

---

### 제한사항

- 1 ≤ `arr`의 길이 ≤ 1,000
    - 0 ≤ `arr`의 원소 ≤ 1,000,000
- 1 ≤ `queries`의 길이 ≤ 1,000
    - 0 ≤ `s` ≤ `e` < `arr`의 길이

---

### 입출력 예

| arr | queries | result |
| --- | --- | --- |
| [0, 1, 2, 3, 4] | [[0, 1],[1, 2],[2, 3]] | [1, 3, 4, 4, 4] |

---

### 입출력 예 설명

입출력 예 #1

- 각 쿼리에 따라 `arr`가 다음과 같이 변합니다.

| i | queries[i] | arr |
| --- | --- | --- |
| - | - | [0, 1, 2, 3, 4] |
| 0 | [0,1] | [1, 2, 2, 3, 4] |
| 1 | [1,2] | [1, 3, 3, 3, 4] |
| 2 | [2,3] | [1, 3, 4, 4, 4] |
- 따라서 [1, 3, 4, 4, 4]를 return 합니다.

## 문제 풀이:

```java
class Solution {
    public int[] solution(int[] arr, int[][] queries) {
        for(int i=0;i<queries.length;i++){
            int s=queries[i][0];
            int e=queries[i][1];
        for (int j=s;j<=e;j++){
                arr[j]++;
            }
      }    
        return arr;
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (1.79ms, 80.3MB)
테스트 2 〉	통과 (1.27ms, 78.4MB)
테스트 3 〉	통과 (0.19ms, 74.4MB)
테스트 4 〉	통과 (0.08ms, 68.5MB)
테스트 5 〉	통과 (0.07ms, 73.2MB)
테스트 6 〉	통과 (0.03ms, 77.9MB)
테스트 7 〉	통과 (1.95ms, 83MB)
테스트 8 〉	통과 (1.52ms, 78.7MB)
테스트 9 〉	통과 (1.63ms, 78.5MB)
테스트 10 〉	통과 (2.01ms, 74.9MB)
테스트 11 〉	통과 (1.40ms, 75.6MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

```java
class Solution {
    public int[] solution(int[] arr, int[][] queries) {
       int[] diff = new int[arr.length + 1];
        for(int i = 0; i < queries.length; i++) {
            int start = queries[i][0];
            int end = queries[i][1];
            
            diff[start] += 1;
            diff[end + 1] -= 1;
        }
        for (int i = 1; i < arr.length; i++) {
            diff[i] += diff[i - 1];
        }
        for (int i = 0; i < arr.length; i++) {
            arr[i] += diff[i];
        }
        return arr;
    }
}
-----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.09ms, 75MB)
테스트 2 〉	통과 (0.07ms, 87.8MB)
테스트 3 〉	통과 (0.04ms, 70.5MB)
테스트 4 〉	통과 (0.03ms, 74.5MB)
테스트 5 〉	통과 (0.06ms, 74MB)
테스트 6 〉	통과 (0.06ms, 77.4MB)
테스트 7 〉	통과 (0.12ms, 82.2MB)
테스트 8 〉	통과 (0.10ms, 68.4MB)
테스트 9 〉	통과 (0.08ms, 75.3MB)
테스트 10 〉	통과 (0.17ms, 77MB)
테스트 11 〉	통과 (0.08ms, 75.6MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

### **문제 풀이 해석:**

arr 배열에 쿼리의 범위내 있는 값들을 1씩 증가시키는 문제다. 처음 풀이는 2중 for문을 써서 쿼리의 앞 원소를 시작, 뒤 원소를 끝으로 설정해 arr 배열의 값을 증가시키는 풀이를 사용했다.

두번째 풀이는 쿼리를 처리할 배열을 생성하고 쿼리를 처리한 다음에 원 배열인 arr 배열에 더하는 형식으로 풀었다.

첫번째 풀이의 시간복잡도는 쿼리의 개수 x 배열의 길이지만, 두번째 풀이의 시간복잡도는 쿼리의 개수+ 배열의 길이가 된다.