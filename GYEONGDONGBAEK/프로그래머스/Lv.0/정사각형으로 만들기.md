# [프로그래머스] 정사각형으로 만들기

## 문제 링크:

[문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/181830)

## 문제 설명:

이차원 정수 배열 `arr`이 매개변수로 주어집니다. `arr`의 행의 수가 더 많다면 열의 수가 행의 수와 같아지도록 각 행의 끝에 0을 추가하고, 열의 수가 더 많다면 행의 수가 열의 수와 같아지도록 각 열의 끝에 0을 추가한 이차원 배열을 return 하는 solution 함수를 작성해 주세요.

---

### 제한사항

- 1 ≤ `arr`의 길이 ≤ 100
- 1 ≤ `arr`의 원소의 길이 ≤ 100
    - `arr`의 모든 원소의 길이는 같습니다.
- 1 ≤ `arr`의 원소의 원소 ≤ 1,000

---

### 입출력 예

| arr | result |
| --- | --- |
| [[572, 22, 37], [287, 726, 384], [85, 137, 292], [487, 13, 876]] | [[572, 22, 37, 0], [287, 726, 384, 0], [85, 137, 292, 0], [487, 13, 876, 0]] |
| [[57, 192, 534, 2], [9, 345, 192, 999]] | [[57, 192, 534, 2], [9, 345, 192, 999], [0, 0, 0, 0], [0, 0, 0, 0]] |
| [[1, 2], [3, 4]] | [[1, 2], [3, 4]] |

---

### 입출력 예 설명

입출력 예 #1

- 예제 1번의 `arr`은 행의 수가 4, 열의 수가 3입니다. 행의 수가 더 많으므로 열의 수를 4로 만들기 위해 `arr`의 각 행의 끝에 0을 추가한 이차원 배열 [[572, 22, 37, 0], [287, 726, 384, 0], [85, 137, 292, 0], [487, 13, 876, 0]]를 return 합니다.

입출력 예 #2

- 예제 2번의 `arr`은 행의 수가 2, 열의 수가 4입니다. 열의 수가 더 많으므로 행의 수를 4로 만들기 위해 `arr`의 각 열의 끝에 0을 추가한 이차원 배열 [[57, 192, 534, 2], [9, 345, 192, 999], [0, 0, 0, 0], [0, 0, 0, 0]]을 return 합니다.

입출력 예 #3

- 예제 3번의 `arr`은 행의 수와 열의 수가 2로 같습니다. 따라서 0을 추가하지 않고 [[1, 2], [3, 4]]을 return 합니다.

## 문제 풀이:

```java
import java.util.*;
class Solution {
    public int[][] solution(int[][] arr) {
        int max=Math.max(arr.length,arr[0].length);
        int[][] answer=new int[max][max];

        for (int i=0;i<arr.length;i++) {
            for (int j=0;j<arr[i].length;j++) {
                answer[i][j]=arr[i][j];
            }
        }

        return answer;
    }
}
----------------------------------------------------------
정확성  테스트
테스트 1 〉	통과 (0.02ms, 75.8MB)
테스트 2 〉	통과 (0.04ms, 77MB)
테스트 3 〉	통과 (0.04ms, 77.4MB)
테스트 4 〉	통과 (0.06ms, 81.5MB)
테스트 5 〉	통과 (0.07ms, 70.3MB)
테스트 6 〉	통과 (0.05ms, 76.3MB)
테스트 7 〉	통과 (0.06ms, 74MB)
테스트 8 〉	통과 (0.04ms, 74.7MB)
테스트 9 〉	통과 (0.10ms, 78.9MB)
테스트 10 〉	통과 (0.09ms, 84.1MB)
테스트 11 〉	통과 (0.05ms, 74.5MB)
테스트 12 〉	통과 (0.07ms, 75.7MB)
테스트 13 〉	통과 (0.08ms, 78.3MB)
테스트 14 〉	통과 (0.19ms, 89.1MB)
테스트 15 〉	통과 (0.16ms, 85.1MB)
테스트 16 〉	통과 (0.06ms, 83.8MB)
테스트 17 〉	통과 (0.09ms, 74.7MB)
테스트 18 〉	통과 (0.19ms, 78.5MB)
테스트 19 〉	통과 (0.25ms, 83.1MB)
테스트 20 〉	통과 (0.27ms, 72.3MB)
테스트 21 〉	통과 (0.08ms, 83.5MB)
테스트 22 〉	통과 (0.13ms, 80.6MB)
테스트 23 〉	통과 (0.35ms, 88.1MB)
테스트 24 〉	통과 (0.32ms, 76.9MB)
테스트 25 〉	통과 (0.04ms, 76.6MB)
테스트 26 〉	통과 (0.03ms, 77.6MB)
테스트 27 〉	통과 (0.12ms, 80.8MB)
테스트 28 〉	통과 (0.22ms, 82.4MB)
테스트 29 〉	통과 (0.29ms, 81.7MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
```

### **문제 풀이 해석:**

일단 Math.max 메서드를 사용하여 행과 열중 길이가 더 긴 것을 찾아 max값으로 설정했다. 이 후 정답 배열의 크기를 max로 설정 해준 뒤, 정답 배열의 값을 원래 가지고 있던 배열의 값으로 바꿔주는 과정을 통해 더 짧은 길이를 가지고 있던 부분의 값은 다 채워졌다. 문제에서 행과 열의 길이가 같아질때 까지 0을 추가하라고 되어있는데, int 배열은 선언을 하면 기본값이 0 으로 채워지기 때문에, 신경쓰지 않았다.